1) Как правильно вычислять hashCode у объекта.
hashCode у объекта должен вычисляться на основании содержимого объекта (значения полей). При этом:
– вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.
– вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true).
– вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения (это требование не является обязательным).

Общепринятые правила при переопределении метода hashCode():
1. Присвоить результирующей переменной (result) некоторое ненулевое значение;
2. Если поле value имеет тип boolean, вычислить (value ? 0 : 1);
3. Если поле value имеет тип byte, char, short или int, вычислить (int)value;
4. Если поле value имеет тип long, вычислить (int)(value - (value >>> 32));
5. Если поле value имеет тип float, вычислить Float.floatToIntBits(value);
6. Если поле value имеет тип double, вычислите Double.doubleToLongBits(value), а затем преобразовать полученное значение, как указано в п.4;
7. Если поле является ссылкой на объект, а метод equals данного класса сравнивает это поле, рекурсивно вызывая другие методы equals, так же рекурсивно вызывать для этого поля метод hashCode;
8. Если поле value является ссылкой на объект и равно null, использовать число 0 для представления его хэш-кода;
9. Объединить полученные в п.2 - п.8 значения следующим образом: 31 * result + value;
10. Если поле является массивом, применить правило 9 для каждого элемента массива.


2) Как вычисляется hash функция в HashMap. Привести два варианта: через % и >>.
а) Исходный код:
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
Сначала вычисляется промежуточное значение h, оно равно хеш-функции от ключа, затем вычисляется значение, равное нулевому побитовому сдвигу числа h вправо на 16 бит, и для вычисленных выше значений выполняется операция ^ побитовое логическое или.
б) Исходный код:
p = tab[i = (n - 1) & hash]
В методе коллекции, при поиске корзины/индекса хеш-код ключа делится с остатком (%) на размер хеш-таблицы (по умолчанию n=16) и результатом будет число в диапазоне от 0 до n, т.е. номер ячейки в массиве, куда помещается объект с нашим ключом. А т.к. для HashMap размер хеш-таблицы равен степени 2, то вместо %n (остатка от деления) используется более быстрый &(n-1) (побитовое И).
Т.е. вместо index = hash % (n - 1) используется index = (n - 1) & hash